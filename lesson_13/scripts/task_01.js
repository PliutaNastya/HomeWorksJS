"use strict"

// Задача 01. Генерація всіх підмножин: Реалізуйте рекурсивну функцію, яка генерує всі можливі підмножини заданого масиву. Наприклад, для масиву [1, 2, 3] можливі підмножини: [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3].


const generateSubsets = (arr) => {
	
	// Створюємо змінну для зберігання результату у масив
	let res = []

	// Створюємо рекурсивну функцію, яка приймає поточну підмножину і індекс
	const buildSubsets = (currentSubset, index) => {

		// Додаємо до результату КОПІЮ підмножини
		res.push([...currentSubset])
		
		// Створюємо цикл, який буде перебирати масив
		for (let i = index; i < arr.length; i++) {

			currentSubset.push(arr[i]) 

			buildSubsets(currentSubset, i + 1)

			currentSubset.pop()
		}
	}

	buildSubsets([], 0)

	return res
}

const arr = [1, 2, 3]
const resArr = generateSubsets(arr)

for (let i = 0; i < resArr.length; i++) {
	document.write(`<p>Підмножина №${i + 1} - <span>[${resArr[i]}]</span></p>`)
}
console.log(arr)




//! З поясненнями для себе
// const generateSubsets = (arr) => {

// 	// Створюємо змінну для зберігання результату у масив
// 	let res = []

// 	// Створюємо рекурсивну функцію, яка приймає поточну підмножину і індекс
// 	const buildSubsets = (currentSubset, index) => {

// 		// Додаємо до результату КОПІЮ підмножини (спочатку це буде [], з якого все починається і який передається цій функції як параметр)
// 		res.push([...currentSubset])

// 		// Створюємо цикл, який буде перебирати масив, він починається з індекса, який ми задаємо як параметр функції
// 		for (let i = index; i < arr.length; i++) {
// 			// Перша ітерація, i = index, тобто 0
// 			// додаємо до поточної підмножини елемент з індексом 0
// 			currentSubset.push(arr[i]) // currentSubset = [1]

// 			// Викликаємо рекурсивну функцію для наступних елементів
// 			buildSubsets(currentSubset, i + 1)

// 			// Друга ітерація, i = 1
// 			// після першої ітерації це буде func([1], 1)
// 			// res.push([1]), res=[[], [1]]
// 			// [1].push(arr[1]) => [1].push(2) => currentSubset = [1, 2]

// 			// Третя ітерація, i = 2
// 			// після другої ітерації це буде func([1, 2], 2)
// 			// res.push([1, 2]), res=[[], [1], [1, 2]]
// 			// [1, 2].push(arr[2]) => [1, 2].push(3) => currentSubset = [1, 2, 3]

// 			// Четвертої ітерації не буде, тому що i=3, а 3 не менше за довжину масива
// 			// Це був прямий прохід

// 			// Тепер треба йти в зворотньому напрямку, це потрібно для того, аби спробувати інші комбінації
// 			// currentSubset = [1, 2, 3] ось так зараз виглядає масив поточний
// 			// у поточного масиву видаляємо той останній елемент, який ми додали щоб повернутися до попереднього стану і спробувати інші варіанти
// 			currentSubset.pop()

// 			// тепер currentSubset=[1, 2]
// 			// Тепер ми повертаємось до рекурсії, де в нас була підмножина[1, 2].Це означає, що ми вже перебрали всі варіанти для елемента 3, і тепер нам потрібно подивитися, чи можемо додати інші елементи.

// 			// Після того, як ми повернулися до currentSubset = [1, 2], продовжуємо цикл з індексом 2. Ми знову додаємо новий елемент до поточної підмножини і викликаємо рекурсію. Тобто currentSubset = [1, 2, 3] знову. І знову викликаємо рекурсію
// 		}
// 	}

// 	buildSubsets([], 0)

// 	return res
// }



// // Всі можливі комбінації
// const generateCombinations = (step, stopStep, resArr) => {
// 	if (step === stopStep) console.log(resArr)
// 	else {
// 		for (let i = 0; i < stopStep; i++) {
// 			generateCombinations(step+1, stopStep, [...resArr, i])
// 		}
// 	}
// }
// generateCombinations(0, 3, [])

